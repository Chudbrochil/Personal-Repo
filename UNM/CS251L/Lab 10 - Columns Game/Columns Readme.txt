README FOR COLUMNS GAME:
Anthony Galczak - agalczak@unm.edu - WGalczak@gmail.com
CS251 Lab 10 - Columns Game

Game Play:
Scoring:
When making block matches your score will be calculated based on how many blocks
you've eliminated in a single drop. This includes a block "combo".
Removing 3 blocks in one drop - 3 points
Removing 4 blocks in one drop - 5 points
Removing 5 blocks in one drop - 7 points
Removing 6 blocks in one drop - 10 points
Removing 7 blocks in one drop - 15 points
Removing 8 blocks in one drop - 20 points
Removing 9 blocks in one drop - 30 points
Removing 10 or more blocks in one drop - 50 points

Rules:
Columns is a block moving game similar to Tetris or Bejeweled.
You are looking to make combinations of 3 blocks or more of the same color.
Matches are effective vertically, diagonally or horizontally.
If your blocks removed cause more matches of 3 to happen then those blocks removed
will count towards your score also. If you match more than one set of 3 then you
will score bonus points based on how many total blocks you removed.
See the scoring section for more details on points.

Controls:
Left arrow key: Move piece left
Right arrow key: Move piece right
Down arrow key: Move piece down
Up arrow key: Rotate piece
Space bar: Drop piece in place


Program Internals:
Classes:

Block
 * Block object will contain 3 elements among a variable amount of block types.
 * Rotate method allows the user to rotate the block to place the block in a 
 * different configuration. Includes a method for drawing a whole block of
 * 3 elements on a Swing GUI given a Graphics object.

BlockManager
 * Model class for the Columns game.
 * 
 * Includes many methods for manipulating a board with Blocks.
 * Removing, searching for matches, dropping blocks, etc.
 * 
 * All of this will be displayed in a GUI to represent physical
 * blocks that will be moved around.
 
BlockManagerTest
 * Test class for testing the BlockManager class' functionality.
 * Will drop multiple blocks onto a simulated ASCII board and
 * verify the logic of removing blocks, counting blocks removed
 * and then dropping blocks above down. 
 
ColumnsFrame
 * I like to think of this class as the "Master GUI". This class holds all
 * of the panels that will be used as well as the introductory dialog for
 * polling the user on what game type they would like.
 * 
 * The timer, logic for the pause button and its listener, and all of the
 * menu options and their dialogs live here.

GamePanel
 * A wrapper panel for the GameBoard. Holds the overall
 * dimensions of the panel and serves as a parent to GameBoard.

GameBoard
 * Serves somewhat as a Controller between the "real GUI" of the frame
 * and the model class BlockManager. Reality is this class performs some
 * logic around the moving block and handling it.
 * 
 * This class handles all of the painting of the moving block as well as
 * the static blocks on the "ground" of the board.
 * 
 * Any sounds coming from the game come from this class.
 * 
 * The timer in the frame above the hierarchy runs this class' "timer" via
 * the setPlaying method. If isPlaying is set to true then all the listeners
 * are listening and we are set to play. Otherwise, everything is ignored.

COLUMNS_CONSTANTS
 * Contains constants for use throughout the program.
 * Primarily this contains sizing for the various game
 * types and any long strings used in help popups.

ColorMap
 * Map class that holds mappings between 8 possible characters in the
 * internal BlockManager and maps them to the appropriate colors in order
 * to be painted on a Swing GUI.
 * 
 * This class is a fancy static data type for a map that is used throughout
 * the program.

Algorithm details:
The random piece is generated by passing in a random object to the Block constructor.
It then uses this random object to create 3 random elements based upon how many block types have been selected.

Moving and placing pieces is handled by placing internal characters into a character array that is held
in BlockManager. There is a class that serves as a map that we use later on to map these characters to
colors to be painted called ColorMap.

Detecting lines of the same block is done all within BlockManager. BlockManager searches via the search
method based upon the piece that was actually dropped. You only need to search the 3 elements of the dropped
piece. I have implemented this in such a way that we only have to go to the upper left, up, upper right, and
left. From these directions I search forwards and backwards for all matches. These matches are added to a list
of winners that are then removed.

Dropping the blocks back down are also handled within BlockManager. This part is handled within the removeBlocks
method. I only drop blocks in columns that were affected by the "winners". I then calculate what the first blank 
element in the column I'm working on is. From the initial blank element I look for how many total blank elements
above this initial blank. I then find how many non-blank elements are above this one, i.e. how many pieces need
to be dropped. From there I run a loop that loops over each element to drop and drops it down.

The chain of block matches is handled by BlockManager and GameBoard. BlockManager handles the actual removal of the
pieces, but I use a timer in GameBoard to trigger actually removing the pieces and repainting. This turned out
to be a bit more painful than anticipated as I was unaware of the Events from Swing coinciding with eachother as
repaints get stacked up.

I am able to detect the end of the game by analyzing the coordinate that is returned off from dropping a block.
This coordinate is returned from BlockManager dropBlock method. Then when we call the dropBlock method within
the GameBoard class we will want to analyze what row the bottom coordinate is in. If the row is -1, 0, or 1 then
it has been dropped in a spot that is over the top of the board. Then we need to initiate the actual game over
sequence. GameBoard calls gameOver and resets some member variables and then calls gameOver on the Frame itself.


Enhancements I'd like to do:
1. Confirm to a more strict "MVC design pattern" and remove the dependencies between classes
    - Ideally this should be MVC, but I have logical calls all over between the frame and panel, i.e. gameOver method
2. Implement 2 side-by-side GUIs to do two-player mode
3. Put a Sound/No Sound toggle on the beginning frame that shows up.
4. Preview panel


Bonus features I did do:
1. Initial game-select menu of SMALL, MEDIUM, LARGE game modes. Takes advantage of
   the flexibility of creating different BlockManager/GameBoard classes.
2. Highlighting for the column that the piece is in. In my opinion this is a simple
   change, but helps game play considerably.
3. Help MenuBar including PopUps for Rules, Scoring and Controls. This serves as a 
   readme for the user within the file.
4. Ability to restart the game on game over. A PopUp will appear and ask the user
   if they'd like to play again and then refresh the state of the game to go again.
5. Tons of code optimizations including using lambda's for some action listeners and
   using HTML in the welcome game type dialog to display multi-line buttons. Also
   have a CONSTANTS file that includes the constants that I'm using all around
   the program.

